\documentclass[10pt]{book}%%usa draft per trovare overfull
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
%\usepackage{courier}
\usepackage[framemethod=tikz]{mdframed}
\usepackage{xcolor}

\newcommand{\e}{\`{e} }
\newcommand{\ac}[1]{\`{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\renewcommand{\emph}[1]{\textbf{#1}}
\newenvironment{codeenv}{
\begin{mdframed}[backgroundcolor=black!20,topline=false,leftline=false,rightline=false,bottomline=false]
}
{\end{mdframed}}

\author{De Donato Paolo}
\title{\textbf{\huge Il linguaggio Meucci\\
\large Versione 2.0.0}}
\date{}

\begin{document}
\maketitle
\tableofcontents
\chapter{Introduzione}
\section{Panoramica}
Il linguaggio Meucci \e incentrato principalmente sul concetto di \emph{modulo} piuttosto alle funzioni del Lisp o agli oggetti del Java. Un modulo nel linguaggio Meucci \e un \emph{contenitore di funzioni e oggetti che svolgono una particolare funzione}. Il concetto di modulo \e molto simile a quello di namespace in C++ o di package in Java, ma a differenza del Meucci questi linguaggi hanno posto maggior attenzione al concetto di oggetto (in particolare il Java), assegnando quindi ai moduli un ruolo marginale.

Ovviamente chi \e del tutto estraneo al mondo della programmazione non avr\`{a} quasi sicuramente capito molto dalle righe precedenti. Per comprendere meglio i concetti di tipo (che in altri linguaggi equivarrebbe agli oggetti), funzione e modulo presenti nel linguaggio Meucci utilizzeremo il seguente paragone.

\textit{Supponiamo che la nostra applicazione sia una fabbrica di liquori. Essa \e composta da vari \textbf{moduli}, che equivarrebbero ai vari reparti della fabbrica. Prendiamo ora in esame il reparto di distillazione. I \textbf{tipi} potrebbero essere uno il "mosto" gi\`{a} fermentato ma che deve essere distillato, un altro il distillato, un altro gli aromi ... ovvero tutti gli oggetti concreti su cui \e possibile effettuare operazioni di "lettura" (\e possibile analizzare le sue caratteristiche) e/o "scrittura" (\e possibile modificare le sue caratteristiche, magari combinandole con altri oggetti). Ovviamente non esiste un solo aroma, esiste ad esempio l'aroma della fragola, del limone, l'aroma della ciliega, etc. . Ciascuno di questi aromi corrisponderebbe all'interno del nostro programma ad una \textbf{variabile del tipo "aroma"}. Le \textbf{funzioni/operazioni} potrebbero essere i distillatori, le macchine di miscelazione, ... ovvero tutte le macchine che trasformano i prodotti grezzi (le variabili di un tipo prefissato passate alle funzioni), in prodotti elaborati (il valore di ritorno). In una grande fabbrica di liquori non esiste chiaramente solo il reparto di distillazione, esiste anche il reparto di fermentazione, il reparto di imballaggio e distribuzione, il reparto contabilit\`{a} e il reparto che permette agli altri reparti di comunicare tra loro. Chiaramente, se l'azienda \e molto piccola, \e possibile utilizzare un solo reparto che effettui tutte queste operazioni, ma sarebbe tutto pi\`{u} incasinato e problematico, soprattutto all'aumentare della grandezza della fabbrica.}

\section{Compilazione}
Per poter creare un eseguibile a partire dai sorgenti c'\e bisogno di un particolare programma detto \emph{compilatore}. L'attuale compilatore \e il \code{mecc}, e i file contenenti i sorgenti devono avere come estensione \code{.x}. Supponiamo di voler compilare il file sorgente \code{Inizio.x} contenente le seguenti righe di codice:

\begin{codeenv}
\begin{verbatim}
modulo Inizio{
  int main(){
    println("Stringa stampata a video!");
    //Commento ignorato dal compilatore
  }
}
\end{verbatim}
\end{codeenv}

Se vogliamo compilare il programma su un sistema operativo Linux baster\`{a} navigare con la shell fino alla cartella contenente il nostro file e battere il seguente comando:

\begin{codeenv}
\begin{verbatim}
meucci@Meucci:/home/meucci/Code$mecc Inizio.x
\end{verbatim}
\end{codeenv}

otterremo in tal modo l'eseguibile \code{a.out}. Proviamo ad eseguirlo
\begin{codeenv}
\begin{verbatim}
meucci@Meucci:/home/meucci/Code$./a.out
Stringa stampata a video!
meucci@Meucci:/home/meucci/Code$
\end{verbatim}
\end{codeenv}
\subsection*{Analisi del programma}
Analizziamo pi\`{u} nel dettaglio la struttura del programma. La prima riga \code{modulo Inizio} definisce un nuovo modulo di nome Inizio. Il corpo del modulo \e contenuto all'interno di una coppia di parentesi graffe
\begin{codeenv}
\begin{verbatim}
{
...
}
\end{verbatim}
\end{codeenv}
In particolare il modulo contiene una funzione di nome \code{main} senza parametri di input e che ritorna un numero (un tipo particolare di numero in Meucii si esprime con \code{int}) che, tramite la funzione
\begin{codeenv}
\begin{verbatim}
println("Stringa stampata a video!");
\end{verbatim}
\end{codeenv}
stampa a video la stringa passata come parametro di input. La funzione \code main \e particolare, in quanto il programma inizia l'esecuzione sempre dalla funzione con questo nome.

\subsection*{File generati}
Dopo aver effettuato la compilazione, si noter\ac a che \e stato generato un nuovo file col nome \code{Inizio.in}. Questo file ha una funzione simile a quella dei file intestazione del C, ovvero permettere ad altri moduli di poter utilizzare le funzioni ed eventuali tipi del modulo \code{Inizio}.

Questo argomento verr\ac a trattato pi\ac u in dettaglio nel capitolo dei moduli.

\chapter{Istruzioni fondamentali}
\section{Dichiarazione di variabili}
Per comprendere pi\ac{u} a fondo il funzionamento di un programma, dobbiamo conoscere alcune componenti del calcolatore (che pu\ac o essere un normale computer desktop, un mainframe o un cellulare ...), in particolare la \emph{memoria centrale} (conosciuta anche col nome di memoria RAM). Un qualunque programma infatti viene copiato all'interno della memoria centrale per poter essere eseguito dalla CPU e per poter memorizzare dati necessari alla corretta esecuzione. La memoria viene vista dalla CPU come se fosse una sequenza di byte, a ciascuno dei quali \e associato un indirizzo univoco. Una \emph{variabile} in Meucci (e in qualunque altro linguaggio di programmazione) non \e nient'altro che un \emph{indirizzo} di una \emph{locazione di memoria} (uno o pi\ac u bytes consecutivi) della memoria centrale, su cui possono essere eseguite le operazioni di \emph{lettura dati} e di \emph{scrittura dati}, che il programma utilizza per memorizzare temporaneamente un dato necessario all'elaborazione.

Per utilizzare una variabile \e necessario che essa sia \emph{dichiarata}, ovvero che il compilatore sia informato della sua esistenza affinch\'e possa associargli un indirizzo in memoria. Nella dichiarazione di una variabile deve essere specificato il \emph{nome} della variabile, che verr\ac a utilizzato nel programma per accedere alla variabile, e il \emph{tipo} di dati che la variabile pu\ac o contenere. Il nome di una variabile pu\ac o essere una qualunque sequenza di numeri o lettere, purch\'e non contenga spazi e che il primo carattere sia una lettera. Inoltre il Meucci \e \emph{case sensitive} (ovvero distingue le lettere maiuscole da quelle minuscole). La seguente riga di codice mostra come si dichiara una variabile:
\begin{codeenv}
\begin{verbatim}
int a;
\end{verbatim}
\end{codeenv}
In questa riga di codice \e stata dichiarata una variabile di tipo \code{int} e di nome \code{a}. In Meucci, come in ai devono creare delle funltri linguaggi, al termine di ogni istruzione bisogna porre il carattere \code{;} e, dato che la dichiarazione di una variabile \e essa stessa una istruzione, deve essere terminata da un punto e virgola.
Analizziamo ora un esempio un po' pi\ac u complesso:
\begin{codeenv}
\begin{verbatim}
int a;
int b;
String c;
a = 4;
b = a * 2 + 8;
\end{verbatim}
\end{codeenv}
In questo esempio sono state dichiarate tre variabili distinte: due di tipo \code{int} e una di tipo \code{String}. Per poter scrivere un dato in una variabile si usa il simbolo \code{=} con a sinistra il nome della variabile in cui scrivere il dato, e a destra il dato da scrivere nella variabile (nel nostro esempio abbiamo posto nella variabile \code{a} il valore intero \code{4}). A destra dell'operatore di assegnazione \e possibile inserire espressioni anche pi\ac u complesse, nell'ultima riga infatti il programma effettua le seguenti operazioni:
\begin{enumerate}
\item Legge il valore contenuto nella variabile \code{a}
\item Lo moltiplica per \code{2}
\item Somma al risultato il numero \code 8
\item Scrive il risultato nella variabile \code b
\end{enumerate}
Alla fine dell'esecuzione delle istruzioni precedenti la variabile \code a conterr\ac a il valore \code 4, mentre la variabile \code b il valore \code{16}.
Quando si dichiara una nuova variabile essa si trova in uno stato \emph{indefinito} (ovvero non \e possibile determinare il suo contenuto), per questo prima di ogni utilizzo essa si deve \emph{inizializzare}, ovvero bisogna scriverci dentro un valore noto. In Meucci \e possibile dichiarare e inizializzare una variabile in una sola istruzione, in tal modo l'esempio precedente diviene:
\begin{codeenv}
\begin{verbatim}
int a = 4;
int b = a * 2 + 8;
String c;
\end{verbatim}
\end{codeenv}

\subsection{Dichiarazioni auto}
In una dichiarazione bisogna sempre specificare il tipo di una variabile. Spesso, soprattutto se si utilizzano parametri template, il nome di un tipo risulta essere troppo lungo. In Meucci \e possibile utilizzare in una dichiarazione con assegnazione al posto del nome del tipo l'identificativo \emph{auto}, che dice al compilatore di determinare il tipo della variabile direttamente dal tipo di ritorno dell'espressione di assegnamento. Dunque l'esempio seguente
\begin{codeenv}
\begin{verbatim}
auto x = 32;
\end{verbatim}
\end{codeenv}
dichiara una variabile di tipo \code{int} (vedere il prossimo paragrafo) e gli assegna il valore intero 32. Ovviamente la dichiarazione tramite l'identificativo auto richiede un assegnazione, altrimenti il compilatore generere\ac a un errore.

\subsection{Visibilit\ac a delle variabili}
Un \emph{blocco di istruzioni} \e una seguenza di istruzioni racchiuse tra parentesi graffe. Il corretto utilizzo dei blocchi aumenta la leggibilit\ac a del codice e permette anche di ridurre la memoria inutilizzata tramite il concetto di \emph{visibilit\ac a} (o \emph{scope}) di una variabile.

In parole povere, se una variabile viene dichiarata all'interno di un blocco di istruzioni allora sar\ac a accessibile solo all'interno di tale blocco. In tal modo il compilatore potr\ac a liberare la memoria riservata alle variabili dichiarate all'interno del blocco una volta usciti dallo stesso, riutilizzando la memoria per le altre variabili.

\section{Tipi primitivi e costanti}
Nell'esempio precedente abbiamo utilizzato il tipo \code{int} dando per scontato che fosse il tipo di una variabile numerica. In Meucci esistono due classi di tipi in base a come vengono memorizzati i dati all'interno della memoria: i tipi \emph{primitivi} sono i pi\ac u semplici poich\'e l'indirizzo associato alla variabile punta direttamente ai dati su cui operare; i tipi \emph{reference} invece contengono un \emph{puntatore} ai dati. Pi\ac u avanti tratteremo dei tipi reference, mentre in questa sezione ci concentreremo sui tipi primitivi.

I tipi primitivi sono determinati direttamente dal compilatore, e sono i seguenti:
\begin{itemize}
\item \code{byte} un numero intero con segno memorizzato in 1 byte (compreso tra -128 e 127 inclusi)
\item \code{short} un numero intero con segno memorizzato in 2 bytes (compreso tra -32.768 e 32.767)
\item \code{int} un numero intero con segno memorizzato in 4 bytes (compreso tra -2.147.483.648 e 2.147.483.647)
\item \code{long} un numero intero con segno memorizzato in 8 bytes (compreso tra -9.223.372.036.854.775.808 e 9.223.372.036.854.775.807), disponibile solo per architetture a 64 -bit
\item \code{ubyte} un numero intero senza segno memorizzato in 1 byte (compreso tra 0 e 255)
\item \code{ushort} un numero intero senza segno memorizzato in 2 bytes (compreso tra 0 e 65.535)
\item \code{uint} un numero intero senza segno memorizzato in 4 bytes (compreso tra 0 e 4.294.967.295)
\item \code{ulong} un numero intero senza segno memorizzato in 8 bytes (compreso tra 0 e 18.446.744.073.709.551.615), disponibile solo per architetture a 64 -bit
\item \code{char} un carattere contenuto in 1 byte (come per la codifica ASCII)
\item \code{real} un numero a virgola mobile con precisione doppia (52 bit per mantissa, 11 bit per l'esponente)
\item \code{pt} un puntatore generico (come il \code{void *} del linguaggio C), la dimensione dipende dall'implementazione
\item \code{boolean} un valore booleano (vero o falso) contenuto in 1 byte
\end{itemize}

Le \emph{costanti} sono valori stabiliti a tempo di compilazione, \code{2, 4, 8} sono un esempio di costanti. Come per le variabili, anche le costanti hanno un tipo, determinabile secondo le seguenti regole:
\begin{itemize}
\item Una \code{u} o \code U davanti ad una costante numerica intera esprime che il tipo non ha segno, altrimenti ha segno;
\item Se una costante numerica termina con \code b o \code B allora \e \code{byte} o \code{ubyte}, se termina con \code s o \code S allora \e \code{short} o \code{ushort}, se termina con \code l o \code L allora \e \code{long} o \code{ulong}, se non \e presente \e un \code{int} o \code{uint}
\item Un carattere ASCII deve essere compreso tra due apici singoli (')
\item Una costante a virgola mobile deve contenere un punto, seguito da almeno una cifra (anche 0) 
\end{itemize}
Ecco un esempio di costanti:

\begin{codeenv}
\begin{verbatim}
43
u12S
76b
45.0
U11
908753129L
'h'
123.45632
\end{verbatim}
\end{codeenv}
che sono di tipo rispettivamente: \code{int}, \code{ushort}, \code{byte}, \code{real}, \code{uint}, \code{long}, \code{char}, \code{real}. L'unica costante per \code{pt} \e \code{null}, che rappresenta sempre un indirizzo invalido (esistono altri modi per assegnare a \code{pt} un indirizzo valido).

\section{Conversioni di tipo}
Il linguaggio di programmazione Meucci presenta un meccanismo molto forte di protezione dei tipi: ad ogni variabile di un determinato tipo \e possibile assegnarli solo costanto od espressioni dello stesso tipo: le seguenti istruzioni infatti genereranno errori di compilazione:
\begin{codeenv}
\begin{verbatim}
int a = u4;
\end{verbatim}
\end{codeenv}

\begin{codeenv}
\begin{verbatim}
int a = 4;
long b = a;
\end{verbatim}
\end{codeenv}
l'errore \e generato nella seconda riga

\begin{codeenv}
\begin{verbatim}
int a = 4 + 12b;
\end{verbatim}
\end{codeenv}
L'operazione \code + , come altre operazioni, richiede che i due termini siano dello stesso tipo.

Ovviamente esistono casi in cui bisogna cambiare temporaneamente il tipo di un'espressione per poter essere utilizzato in opportuni contesti (basta pensare alle funzioni). In tal caso \e possibile utilizzare il \emph{casting} del tipo: basta far precedere all'espressione che si vuole convertire con il nome del nuovo tipo racchiuso tra parentesi. Il secondo esempio pu\ac o allora essere corretto nel seguente modo:

\begin{codeenv}
\begin{verbatim}
int a = 4;
long b = (long) a;
\end{verbatim}
\end{codeenv}

Se l'operatore di cast \e utilizzato tra tipi numerici entrambi con o senza segno, e inoltre il nuovo tipo ha una dimensione maggiore o uguale al tipo precedente allora vi \e la garanzia che il valore numerico e l'eventuale segno siano mantenuti. Se invece la conversione avviene tra un tipo numerico con segno e uno senza segno allora il numero viene esteso tenendo conto del nuovo tipo (se \e senza segno viene esteso tramite zeri, altrimenti secondo la specifica del processore per i numeri con segno). Se il nuovo tipo numerico ha dimensione minore del vecchio tipo numerico, allora vengono troncate le cifre pi\ac u significative del numero. Infine, nelle conversioni tra tipi non numerici la situazione \e pi\ac u complessa. In particolare la conversione da \code{real} ad un tipo intero \emph{NON determina la parte intera del numero}, se si vuole calcolare la parte intera di un numero a virgola mobile si dovranno utilizzare opportuni algoritmi. Lo stesso discorso si applica per conversioni da tipi numerici a \code{real}.

\section{Operazioni elementari}
Gli algoritmi per poter operare sui dati vengono eseguiti da due strutture: le funzioni e le operazioni. Le operazioni sono definite tramite un nome, che pu\ac o essere o composto esclusivamente da simboli
\begin{verbatim}
| $ % & + - * / \ ? ^ < > = | ~ @
\end{verbatim}
oppure da una stringa preceduta da : (Es. \code{:new}). Un operazione pu\ac o operare o su un solo parametro (il simbolo va posto prima del parametro) oppure due (il simbolo viene posto tra i due parametri). Di seguito elenchiamo le principali operazioni in Meucci incluse direttamente nel compilatore:

Operazioni con 2 parametri:
\begin{itemize}
\item \verb(+ - * / :mod  (Effettuano rispettivamente addizione, sottrazione, moltiplicazione, divisione e calcolo del resto tra tipi numerici interi dello \emph{stesso tipo}
\item \verb+& | :xor  +Effettuano rispettivamente and, or ed or esclusivo bit a bit di tipi numerici (sempre dello stesso tipo)
\item \verb+== < > <= >= !=  +Confronto di numeri interi dello stesso tipo
\item \verb+&& || ->  +Acettano due espressioni logiche (che ritornano \code{boolean}). \verb+&&+ ritorna \code{true} se e solo se entrambe le espressioni logiche ritornano \code{true}; \verb+||+ ritorna \code{true} se e solo se almeno una espressione ritorna \code{true}; \verb+->+ ritorna \code{false} se e solo se la prima espressione (a sinistra del simbolo) ritorna \code{true} e la seconda ritorna \code{false}
\item \verb+<< >>  +Effettua uno shift a sinistra e a destra di tanti bit quanto \e il valore ritornato dalla seconda espressione. La prima espressione deve ritornare un tipo numerico, mentre la seconda deve ritornare necessariamente \code{ubyte}
\item \verb(+ - * /  (Queste espressioni, oltre che con tipi numerici interi, possono essere utilizzate anche se le espressioni ritornano \code{real}
\end{itemize}

Operazioni con 1 parametro:
\begin{itemize}
\item \verb(++ -- - ~  (Applicato ad espressioni numeriche, rispettivamente incrementano e decrementano di un unit\ac a, effettuano un complemento a 2 (opposto di un numero) e il complemento a 1. A differenza del C/C++, le prime due operazioni non modificano l'espressione su cui sono utilizzate
\item \verb+!  +Applicato ad espressioni logiche, ritorna il negato
\item \verb+:sqrt  +Applicato a espressioni \code{real}, ritorna la radice quadrata
\end{itemize}

Esempi:
\begin{codeenv}
\begin{verbatim}
int a = 4 - 8;
int b = a << u1b;
boolean x = (++ a > b) -> (12 != 12);
\end{verbatim}
\end{codeenv}
A differenza di altri linguaggi di programmazione, in Meucci le regole di associativit\ac a sono solo le seguenti:
\begin{enumerate}
\item Le operazioni con un solo parametro hanno sempre la precedenza sulle operazioni a 2 parametri
\item Se pi\ac u operazioni ad un parametro sono applicate alla stessa espressione allora vengono eseguite da destra a sinistra
\item Le operazioni a due parametri vengono eseguite sempre da sinistra a destra
\end{enumerate}
Quest'ultimo punto pu\ac o generare molta confusione ai programmatori, soprattutto ai pi\ac u esperti. Per esempio l'espressione
\begin{codeenv}
\begin{verbatim}
3 + 4 * 6
\end{verbatim}
\end{codeenv}
ritorna 42 invece di 27 come per il C. Per ovviare a questo inconveniente si possono utilizzare le parentesi tonde. Infatti
\begin{codeenv}
\begin{verbatim}
3 + (4 * 6)
\end{verbatim}
\end{codeenv}
ritorner\ac a 27. Pi\ac u avanti verr\ac a chiarito il motivo che ha portato all'adattamento di questa politica.

\subsection*{Elisione del primo parametro}
Supponiamo di avere queste righe di codice:
\begin{codeenv}
\begin{verbatim}
int a = 4;
a = a + 2;
\end{verbatim}
\end{codeenv}
Dato che, nella seconda riga, l'espressione a sinistra dell'operazione \e la stessa presente a sinistra dell'operazione di assegnamento, \e possibile rimuovere la prima espressione, in modo da ottenere
\begin{codeenv}
\begin{verbatim}
int a = 4;
a =+ 2;
\end{verbatim}
\end{codeenv}
che produrr\ac a lo stesso risultato. Si nota che il simbolo dell'operazione deve seguire il simbolo di assegnazione direttamente e senza spazi, altrimenti verr\ac a interpretato come un'operazione ad un parametro.

\section{Costrutti di controllo ed iterazione}
\subsection{Costrutto if ed if-else}
Fino ad ora abbiamo analizzato le principali istruzioni presenti in Meucci. Queste istruzioni verranno eseguite sequenzialmente all'interno del programma, ma molto spesso si vuole che alcune istruzioni vengano eseguite solo in particolari condizioni. Come in tutti gli altri linguaggi di programmazione, il linguaggio Meucci mette a disposizione il costrutto \code{if} che analizza una particolare espressione logica ed esegue le istruzioni specificate solamente  se l'espressione logica ritorna \code{true}.

Ecco un esempio del'utilizzo del costrutto \code{if}:

\begin{codeenv}
\begin{verbatim}
int x;
...
if(x > 0){
 x =- 1;
}
\end{verbatim}
\end{codeenv}

il programma esegue l'istruzione \code{x =- 1} se e solo se l'espressione logica \code{x > 0} \e verificata.

Analogamente \e presente il costrutto \code{if-else}:
\begin{codeenv}
\begin{verbatim}
int x;
...
if(x > 0){
 x =- 1;
}
else{
 x =+ 1;
}
\end{verbatim}
\end{codeenv}
in questo esempio se \code{x > 0} allora esegue \code{x =- 1}, altrimenti esegue \code{x =+ 1}.

\subsection{Costrutti while e for}
Il costrutto \emph{while} richiama pi\ac u volte un gruppo di istruzioni finch\'e l'espressione logica specificata non ritorna \code{false}.
\begin{codeenv}
\begin{verbatim}
int x;
...
while(x > 0){
 x =- 1;
}
\end{verbatim}
\end{codeenv}
In questo esempio il programma richiama l'istruzione \code{x =- 1} fino a quando l'espressione \code{x > 0} non ritorna \code{false}, in particolare se \code x \e positivo verr\ac a decrementato fino a diventare 0, e quindi esce dal ciclo. Da notare che \code{while} controlla l'espressione prima di eseguire il blocco di istruzioni associato, quindi se \code x contiene un numero negativo o 0 viene lasciato inalterato.

Analogo al costrutto while c'\e anche il costrutto \emph{for}, anch'esso \e un costrutto di iterazione, ma a differenza del \code{while} oltre al blocco di istruzioni da iterare accetta altre tre istruzioni come parametri: la prima deve essere un'espressione, una dichiarazione o un assegnamento che viene eseguita prima di entrare nel blocco, la seconda un espressione logica mentre la terza una espressione generica o un assegnamento che viene eseguita prima del controllo (detta istruzione di \emph{step}). Questi parametri devono essere sempre separati con un ; . Per comprenderne meglio il funzionamento, osserviamo che il seguente costrutto:
\begin{codeenv}
\begin{verbatim}
for(int x = 0; x < 10; x =+ 1){
 println(x);
}
\end{verbatim}
\end{codeenv}
\e del tutto equivalente a
\begin{codeenv}
\begin{verbatim}
int x = 0;
while(x < 10){
 println(x);
 x =+ 1;
}
\end{verbatim}
\end{codeenv}

Le variabili dichiarate nell'intestazione del costrutto for, cos\ac i come quelle definite all'interno di strutture if, while e for, hanno la visibilit\ac a limitata alla struttura stessa, e quindi non possono essere utilizzate all'esterno.

\subsection{break e continue}
All'interno dei costrutti di iterazione sono disponibili due nuove istruzioni:
\begin{itemize}
\item \code{break} Esce immediatamente dal ciclo
\item \code{continue} In un costrutto while salta direttamente alla valutazione dell'espressione logica, mentre in un costrutto for salta all'istruzione di step.
\end{itemize}

\chapter{Moduli}
\section{Creazione di un modulo}
Nell'introduzione abbiamo definito i moduli in Meucci. Ogni funzione, operazione e tipo deve essere contenuto in qualche modulo, e in ogni file ci pu\ac o essere uno ed un solo modulo. Per creare un modulo si utilizza la parola chiave \emph{modulo}, seguita dal nome del modulo e dal corpo (contenente le funzioni ed i tipi) racchiuso da una coppia di parentesi graffe
\begin{codeenv}
\begin{verbatim}
modulo Mode{
...
...
}
\end{verbatim}
\end{codeenv}
\subsection{Importare altri moduli}
Una caratteristica dei moduli in Meucci \e la capacit\ac a di importare le funzionalit\ac a di altri moduli. Per importare moduli \e necessario possedere, oltre alla libreria contenente i codici, anche il relativo file di importazione (terminante con .in) generato durante la compilazione, che si deve trovare in una posizione nota al compilatore.

Per segnalare al modulo di importare un altro modulo si utilizza la parola chiave \emph{depends} seguita dai moduli da importare, seguiti da uno spazio.
\begin{codeenv}
\begin{verbatim}
modulo Mode depends Mod1 Mod2 Mod3{
...
\end{verbatim}
\end{codeenv}

\section{Variabili esterne ed inizializzatore}
Spesso un modulo per svolgere le sue funzionalit\ac a deve immagazzinare dati che non devono essere distrutti al termine delle funzioni e non possono essere passati alla funzione chiamante. Ci\ac o pu\ac o essere ottenuto definendo delle \emph{variabili esterne}, ovvero variabili immagazzinate in una parte della memoria a cui si pu\ac o accedere solo tramite funzionalit\ac a interne al modulo e sopravvivono per tutta la durata del programma.

Una variabile esterna si dichiara come una normale variabile all'interno del corpo del modulo
\begin{codeenv}
\begin{verbatim}
modulo Mode{
 int vesterna1;
 ushort vest2;
 ...
 ...
}
\end{verbatim}
\end{codeenv}

Per inizializzare queste variabili si pu\ac o utilizzare un blocco di istruzioni \emph{static}, che viene eseguito una sola volta che il modulo \e caricato in memoria:
\begin{codeenv}
\begin{verbatim}
modulo Mode{
 int vesterna1;
 ushort vest2;
 static{
  vesterna1 = 0;
  vest2 = u3s;
 }
 ...
 ...
}
\end{verbatim}
\end{codeenv}

\chapter{Funzioni ed operazioni}
\section{Definire funzioni ed operazioni}
Spesso \e utile racchiudere una o pi\ac u istruzioni all'interno di una \emph{funzione} o di un'\emph{operazione} affinch\'e possano essere utilizzate in altri punti del programma senza il bisogno di ricopiare ogni volta tutte le istruzioni, con una significativa riduzione del codice.

Una funzione pu\ac o avere dei \emph{parametri} che possono influenzare le operazioni svolte dalla funzione e che vengono trattati all'interno della funzione come delle variabili. Inoltre una funzione pu\ac o avere o no un \emph{valore di ritorno}, ovvero il risultato che deve essere passato al programma chiamante una volta terminata l'elaborazione della funzione.

Per definire una funzione bisogna prima scrivere il \emph{tipo} del valore di ritorno (o \emph{void} se la funzione non ritorna niente), poi il nome della funzione e infine gli eventuali parametri della funzione, separati da una virgola e racchiusa tra parentesi. Quindi scrivere le istruzioni all'interno di parentesi graffe. Per uscire dalla funzione e ritornare il valore di ritorno di un espressione si utilizza l'istruzione \code{return} seguita dall'espressione. In funzioni che non ritornano niente si pu\ac o utilizzare l'istruzione return senza alcuna espressione.

Ecco un esempio in cui vengono dichiarate delle funzioni:

\begin{codeenv}
\begin{verbatim}
ubute A(){
 return u1b;
}

int valoreassoluto(int a){
 if(a >= 0)
  return a;
 else
  return - a;
}

void niente(ushort a, ushort b){
 if(a < u200S)
  return;
 a =+ b;
}
\end{verbatim}
\end{codeenv}

In Meucci \e possibile definire anche le operazioni in modo analogo alle funzioni, ricordando che possono avere o 1 o 2 parametri solamente.
\begin{codeenv}
\begin{verbatim}
long +-@ (long a, long b){
 ...
}
\end{verbatim}
\end{codeenv}

Il passaggio di parametri a funzioni ed operazioni \e sempre per valore, e mai per riferimento.

\section{Overloading di funzioni ed operazioni}
Come in C++, in Meucci \e supportato l'overloading di funzioni. Per comprendere questo concetto prendiamo in esempio il linguaggio C. In C non \e possibile definire due funzioni con lo stesso nome, in quanto il compilatore distingueva le funzioni solamente in base al nome. In C++ e in Meucci il compilatore distingue le funzioni non solo in base al nome, ma anche in base ai parametri di input della funzione, permettendo quindi al programmatore di definire funzioni simili con lo stesso nome e con parametri diversi senza che il compilatore generi errore. Ogni volta inoltre che si chiama la funzione il compilatore sceglie in base ai  parametri passati quale funzione richiamare.

Il parametro di ritorno non viene considerato dal compilatore per distinguere le funzioni, quindi le seguenti funzioni:
\begin{codeenv}
\begin{verbatim}
...
int funz(ubyte a)
...
uint funz(ubyte v)
...
\end{verbatim}
\end{codeenv}
faranno generare al compilatore un errore.

\section{Ricorsione}
Le funzioni in Meucci supportano la ricorsione, ovvero una funzione pu\ac o richiamare se stessa. Gli algoritmi ricorsivi sono molto utilizzati in quanto permettono di implementare algoritmi semplici e facilmente leggibili, nonostante a volte siano pi\ac u lenti dei loro corrispettivi che utilizzano strutture iterative al posto della ricorsione.

L'esempio utilizzato per mostrare la ricorsione \e l'algoritmo ricorsivo per il calcolo del massimo comune divisore di due numeri interi senza segno
\begin{codeenv}
\begin{verbatim}
uint MCD(uint a, uint b){
 if(b == u0)
  return a;
 else
  return MCD(b, a :mod b);
}
\end{verbatim}
\end{codeenv}

\section{Gestione errori}
Nella versione 2.0.0 del compilatore \e possibile gestire gli errori (chiamati eccezioni in C++ e Java) \emph{solamente per funzioni ed operazioni}. Spesso infatti durante l'esecuzione di un programma possono nascere degli errori che possono essere previsti ma non risolti durante la compilazione (basti pensare agli errori dovuti  all'errato input dell'utente). Per poter gestire queste condizioni eccezionali \e possibile rendere una qualunque funzione o operazione capace di \emph{generare errori}. Molti programmatori alle prime armi sottovalutano l'utilit\ac a della gestione degli errori, ma col crescere delle dimensioni dei programmi cresce conseguentemente la necessti\ac a della gestione degli errori.

\subsection{Dichiarazione e generazione di errori}
Per rendere una funzione (od operazione) capace di generare errori \e necessario specificare i possibili errori che essa genera. A differenza di altri linguaggi come il C++ o il Java in cui le eccezioni sono particolari classi, in Meucci gli errori non sono oggetti a s\'e stanti, e quindi il programmatore non deve creare nuovi oggetti per ogni errore generato, con un conseguente guadagno in prestazioni.

Per dichiarare gli errori che una funzione pu\ac o generare bisogna inserire tra la parentesi tonda chiusa e la parentesi graffa aperta la parola chiave \emph{errors} seguita dai nomi degli errori separati da uno spazio. I nomi degli errori seguono le stesse regole dei nomi delle variabili.
\begin{codeenv}
\begin{verbatim}
void funzione(int par1, ulong par2)errors err1 err2 err3{
 ...
\end{verbatim}
\end{codeenv}

Per generare un errore si utilizza l'istruzione \emph{throw} seguita dal nome dell'errore da generare e da un punto e virgola:

\begin{codeenv}
\begin{verbatim}
throw err2;
\end{verbatim}
\end{codeenv}
\ac E possibile generare un errore non dichiarato dalla funzione, ma ci\ac o causer\ac a l'\emph{immediata terminazione} del programma, in quanto non puÃ² essere gestito.

\subsection{Gestione errori}
Se vogliamo utilizzare una funzione che potrebbe generare errori possiamo seguire due strade:
\begin{enumerate}
\item Dichiarare gli stessi errori nella funzione utilizzatrice facendo propagare l'errore;
\item Utilizzare un blocco try-catch per gestire l'errore. 
\end{enumerate}
Un blocco \emph{try-catch} \e uno speciale blocco che cattura e gestisce gli errori generati. Esso \e composto da:
\begin{itemize}
\item Un blocco \emph{try}: \e semplicemente un blocco di istruzioni. Quando una delle istruzioni contenute genera un errore salta l'esecuzione al blocco catch che gestisce il relativo errore;
\begin{codeenv}
\begin{verbatim}
try{
 istruzione1
 istruzione2
 ...
}
\end{verbatim}
\end{codeenv}
\item Un blocco \emph{catch}: ci possono essere pi\ac u blocchi catch, ciascuno che gestisce un errore diverso. Le istruzioni contenute in esso verranno eseguite solamente se \e stato generato il relativo errore all'interno del blocco try;
\begin{codeenv}
\begin{verbatim}
catch(errName){
 istruzione1
 istruzione2
 ...
}
\end{verbatim}
\end{codeenv}
\item Opzionalmente un blocco \emph{default}: tale blocco viene eseguito solamente se \e stata generato un errore che non pu\ac o essere gestito da nessun blocco catch.
\begin{codeenv}
\begin{verbatim}
default{
 istruzione1
 istruzione2
 ...
}
\end{verbatim}
\end{codeenv}
\end{itemize}

Esempio: Nel seguente esempio \e stato utilizzato un blocco try-catch per controllare l'esecuzione dell'istruzione \code{int var = funzione();}:

\begin{codeenv}
\begin{verbatim}
try{
 int var = funzione();
}
catch(Err1){
 //Se viene generato Err1 l'esecuzione passa qui:
 println("Err1");
}
catch(Err2){
 //Se viene generato Err2 l'esecuzione passa qui:
 println("Err2");
}
default{
 //Se viene generato un errore che non e' 
 //Err1 ne' Err2 l'esecuzione passa qui:
 println("ErrGenerico");
}
\end{verbatim}
\end{codeenv}

\chapter{Tipi reference}
\section{Creazione di tipi reference}
Precedentemente abbiamo visto quali sono i tipi primitivi in Meucci, in particolare abbiamo visto che non \e possibile aggiungere nuovi tipi primitivi senza aggiornare il compilatore. I tipi reference invece possono essere creati direttamente dal programmatore e memorizzati in una libreria per poter essere utilizzati in seguito.

Abbiamo gi\ac a detto che quando quando si dichiara una variabile di tipo reference viene allocata memoria per il \emph{puntatore} che punta ai dati veri e propri del tipo. Un tipo reference \e composto da una o pi\ac u variabili chiamate \emph{campi} del tipo, che insieme immagazzinano tutte le informazioni associate al tipo reference.

Per comprendere megio questi concetti utilizzeremo un esempio classico. Supponiamo di voler creare il tipo Punto, ovvero un punto su di un piano cartesiano reale, che \e identificato univocamente dalla coordinata delle ascisse (x) e quella delle ordinate (y). Il nostro tipo Punto verr\ac a creato cos\ac i:
\begin{codeenv}
\begin{verbatim}
type Punto{
 real x;
 real y;
}
\end{verbatim}
\end{codeenv}
Per creare un nuovo tipo reference bisogna utilizzare l'identificatore \emph{type}, seguito dal nome del tipo, e quindi da ciascun campo terminato con un ; .

A ciascun campo possono essere associati dei modificatori, divisi in due categorie:
\begin{itemize}
\item I modificatori di \emph{memorizzazione} esprimono come \e memorizzato il campo all'interno del tipo. Gli attuali modificatori di memorizzazione sono \code{explicit}, \code{ghost} e \code{override}
\item I modificatori di \emph{accesso} esprimono come deve avvenire l'accesso al campo. Gli attuali modificatori di accesso sono \code{read} e \code{shadow}
\end{itemize}
Ogni campo pu\ac o avere al pi\ac u un modificatore di memorizzazione e al pi\ac u un modificatore di accesso, e il modificatore di memorizzazione deve sempre precedere l'eventuale modificatore di accesso.

Pi\ac u avanti analizzeremo nel dettaglio le funzioni di ciascun modificatore.

\section{Variabili reference}
Come per i tipi primitivi, \e possibile dichiarare variabili di tipo reference come per i tipi primitivi:
\begin{codeenv}
\begin{verbatim}
type Frazione{
 int num;
 int den;
}
...
...
Frazione var;
\end{verbatim}
\end{codeenv}
Per accedere ai campi di una variabile reference si utilizza il simbolo punto (.) seguito dal nome del campo a cui accedere:
\begin{codeenv}
\begin{verbatim}
int i = var.num;
var.den = - 234;
\end{verbatim}
\end{codeenv}

\subsection{Allocazione di oggetti}
Quando dichiariamo una variabile reference in realt\ac a stiamo creando una variabile contenente un puntatore che dovrebbe puntare al relativo oggetto. Dato che non abbiamo ancora creato un oggetto idoneo il puntatore punter\ac a ad una locazione di memoria casuale e non prevedibile.

Per evitare la sovrascrittura di dati fondamentali al programma (in casi estremi si potrebbe arrivare anche al crash del sistema) \e opportuno inizializzare il puntatore per farlo puntare ad un indirizzo sicuramente non valido. Ci\ac o pu\ac o essere ottenuto tramite l'espressione costante \emph{null}, che pu\ac o essere utilizzato anche per inizializzare una variabile \code{pt}.
\begin{codeenv}
\begin{verbatim}
Frazione var = null;
pt pointer = null;
\end{verbatim}
\end{codeenv}

Ovviamente una variabile inizializzata a \code{null} \e nella maggior parte dei casi inutile. Meucci per\ac o possiede dei "pseudo-operatori" che allocano l'oggetto in memoria e ritornano un puntatore all'oggetto, che pu\ac o essere assegnato alla relativa variabile:
\begin{enumerate}
\item \emph{:stack} Alloca l'oggetto direttamente nello stack. L'allocazione viene effettuata molto velocemente ma viene distrutto una volta usciti dal blocco in cui \e stato chiamato
\item \emph{:new} Alloca l'oggetto nello heap. L'allocazione \e pi\ac u lenta rispetto a :stack, ma l'oggetto sopravvive al blocco in cui \e stato creato e quindi pu\ac o essere ritornato da una funzione. Per essere distrutto bisogna utilizzare la pseudo-operazione \emph{:destroy}
\item \emph{:static} L'allocazione \e immediata ma al contempo sopravvive al blocco in cui \e creato. L'oggetto viene creato una ed una sola volta, anche se l'istruzione si trova all'interno di un ciclo o di una funzione chiamata pi\ac u volte. Non deve essere distrutto, se si prova a distruggere un oggetto allocato con :static si andr\ac a incontro quasi sicuramente ad un errore logico. Utilizzato soprattutto negli inizializzatori dei moduli.
\end{enumerate}
Ecco alcuni esempi di utilizzo:
\begin{codeenv}
\begin{verbatim}
Frazione f = :stack Frazione();
Ref g = :new Ref();
Frazione h = :static Frazione();
...
:destroy g;
\end{verbatim}
\end{codeenv}

\subsection{Costruttori e distruttori}
Se si prova ad eseguire il codice precedente il compilatore generer\ac a un errore. Difatti :new, :stack e :static allocano lo spazio necessario all'oggetto ma non inizializzano i campi, che sono lasciati in uno stato indefinito. Per inizializzare un oggetto bisogna utilizzare una particolare funzione definita all'interno del tipo, detto \emph{costruttore}, che si occuper\ac a di inizializzare correttamente i campi. Per accedere ai dati dell'oggetto si deve utilizzare la variabile \emph{this} dello stesso tipo dell'oggetto da inizializzare. Un costruttore pu\ac o avere dei parametri di input come per le funzioni, che verranno passati durante l'allocazione della memoria, e in un tipo ci possono essere pi\ac u costruttori distinti, purch\ac e abbiano diversi parametri.

Oltre al costruttore in un oggetto deve essere definito anche un \emph{distruttore}, che verr\ac a chiamato quando verr\ac a liberata la memoria associata all'oggetto. A differenza del costruttore vi potr\ac a essere un solo distruttore per ciascun oggetto e non pu\ac o avere parametri, anche se si puac o utilizzare this per accedere all'oggetto.

Un costruttore deve avere come nome \emph{init}, mentre un distruttore \emph{end}, in entrambi il tipo di ritorno \emph{non} deve essere specificato (ma pu\ac o essere considerato \code{void}) e devono terminare con un punto e virgola.
\begin{codeenv}
\begin{verbatim}
type Frazione{
 int num;
 int den;
 init(int num, int de){
  this.num = num;
  this.den = de;
 };
 init(int n){
  this.num = n;
  this.den = 1;
 };
 end(){
 
 };
}
...
...
Frazione f = :new Frazione(1, 2);
Frazione g = :stack Frazione(3);
\end{verbatim}
\end{codeenv}

\section{Funzioni di accesso e modificatori explicit e ghost}
Prendiamo sempre in esempio il tipo Frazione, e definiamolo all'interno di un modulo di nome Frazioni. Se ora volessimo accedere ad un campo di una variabile di tipo Frazione dichiarata in un altro modulo, in realt\ac a non accediamo direttamente al campo in questione, ma \emph{viene chiamata una particolare funzione} che per default accede in lettura o in scrittura al relativo campo.

Se per motivi di performance si vuole evitare la creazione delle funzioni di accesso e permettere anche a moduli esterni di accedere direttamente al campo si utilizza il modificatore di memorizzazione \emph{explicit}:
\begin{codeenv}
\begin{verbatim}

type Frazione{
 explicit int num;
 explicit int den;
 init(int num, int de){
  this.num = num;
  this.den = de;
 };
 init(int n){
  this.num = n;
  this.den = 1;
 };
 end(){
 
 };
}
\end{verbatim}
\end{codeenv}
Ci sono situazioni in cui pu\ac o far comodo utilizzare le funzioni di accesso per proteggere i dati memorizzati nei relativi campi. Per sovrascrivere le funzioni di accesso di default basta creare un blocco subito dopo il campo e quindi, se si vuole sovrascrivere la funzione di lettura, dichiarare una funzione di nome \emph{get} mentre, per sovrascrivere la funzione di scrittura, dichiarare una funzione di tipo \emph{set}. Queste funzioni devono per\ac o soddisfare le seguenti caratteristiche:
\begin{itemize}
\item La funzione get deve avere come tipo di ritorno il tipo del campo e non pu\ac o avere parametri di input
\item La funzione set deve avere void come "tipo di ritorno", e deve avere un solo parametro di input dello stesso tipo del campo
\end{itemize}
Entrambe le funzioni possono utilizzare this per accedere all'oggetto.

Ritorniamo al nostro tipo Frazione: una frazione deve avere necessariamente il denominatore diverso da 0 per esistere, ma cos\ac i come \e scritta potrebbe essere posto tranquillamente a 0 con il rischio di generare errori logici. Utilizziamo le funzioni di accesso per prevenire a questa eventualit\ac a:
\begin{codeenv}
\begin{verbatim}
type Frazione{
 int num;
 int den{
  void set(int val){
   if(val == 0)
    this.den = 1;
   else
    this.den = val;
  }
 };
 init(int num, int de){
  this.num = num;
  this.den = de;
 };
 init(int n){
  this.num = n;
  this.den = 1;
 };
 end(){
 
 };
}
\end{verbatim}
\end{codeenv}
Da notare che all'interno del modulo Frazioni ogni accesso ai campi di variabili Frazione sar\ac a sempre diretto. Se si vuole che un accesso sia mediato dalla relativa funzione si deve utilizzare al posto del punto singolo (.) due punti affiancati (..)
\begin{codeenv}
\begin{verbatim}
var..den = 3;
\end{verbatim}
\end{codeenv}

Le funzioni di accesso sono molto potenti: negli esempi precedenti quando si dichiara un campo viene allocato lo spazio sufficiente per contenere il dato. In Meucci \e possibile dichiarare campi \emph{senza allocare spazio al campo stesso}, ma regolando gli accesso tramite le funzioni di accesso. Si crea quindi una sorta di campo fantasma, in cui viene data l'illusione dell'esistenza del campo quando gli accessi vengono tutti evasi dalle funzioni di accesso. Ovviamente per un campo ghost si dovranno specificare entrambe le funzioni di accesso.

Supponiamo di aggiungere un campo fantasma al nostro tipo Frazione che ritorna la parte intera del nostro oggetto (bench\'e sarebbe pi\ac u corretto definire una funzione distinta che calcoli la parte intera). Si utilizzer\ac a il modificatore di memorizzazione \emph{ghost} per creare un campo fantasma:
\begin{codeenv}
\begin{verbatim}
type Frazione{
 int num;
 int den{
  int get(){
   return this.den;
  }
  void set(int val){
   if(val == 0)
    this.den = 1;
   else
    this.den = val;
  }
 };
 ghost int parteIntera{
  int get(){
   return num/den;
  }
  void set(int v){
  
  }
 };
 init(int num, int de){
  this.num = num;
  this.den = de;
 };
 init(int n){
  this.num = n;
  this.den = 1;
 };
 end(){
 
 };
}
\end{verbatim}
\end{codeenv}
Se un campo \e ghost, allora anche all'interno del modulo l'accesso sar\ac a mediato dalle funzioni.

\subsection{Tipi explicit}
Per migliorare le performance di accesso di un oggetto o per poter calcolare esattamente le dimensioni dello stesso si sarebbe tentati di dichiarare explicit ogni campo del tipo. In realt\ac a vengono generate comunque altre strutture inutili (basta pensare alle vtable per gestire l'ereditariet\ac a). Per impedire la creazione di queste altre strutture si pu\ac o rendere l'intero tipo explicit ponendo tale parola chiave tra il nome e la parole type:
\begin{codeenv}
\begin{verbatim}
type explicit Struct{
\end{verbatim}
\end{codeenv}
In un tipo explicit l'accesso a tutti i campi sar\ac a sempre diretto, e l'unico modificatore di memorizzazione ammesso \e explicit (che viene naturalmente ignorato).
 
C'\e per\ac o un prezzo da pagare: Un tipo explicit pu\ac o estendere solo tipi explicit e per estendere un tipo explicit anche il sovrattipo dovr\ac a essere explicit. Inoltre \emph{non si potr\ac a specificare un distruttore}. Questi argomenti verranno trattati nel capitolo dell'ereditariet\ac a.

\section{Accesso con parametri}
A differenza di altri linguaggi di programmazione, Meucci permette di accedere ai campi anche attraverso dei parametri. Per comprendere meglio consideriamo il tipo IntArray, un array di interi. Per accedere ad un generico dato memorizzato nell'array si utilizza un parametro intero, che in questo specifico caso viene chiamato indice. Tramite le funzioni di accesso \e possibile specificare parametri aggiuntivi per accedere al campo, che in Meucci deve possedere il modificatore \emph{ghost}. Per specificare i parametri di accesso bisogna:
\begin{enumerate}
\item Scrivere subito dopo il campo in ordine i tipi dei parametri di accesso racchiusi tra parentesi quadre e separati da una virgola
\item Specificare entrambe le funzioni di accesso con i relativi parametri di accesso in ordine e sempre dopo l'eventuale parametro di scrittura per la funzione set.
\end{enumerate}

Ecco lo pseudo-codice del nostro tipo IntArray:
\begin{codeenv}
\begin{verbatim}
type IntArray{
 int len;
 pt pointer;//Punta alla memoria dell'array
 ghost int elem[int]{
  int get(int index){
   if((index >=0) && (index < len)){
    'ritorna elemento'
   }
   else
    return 0;
  }
  void set(int val, int index){
   if((index >=0) && (index < len)){
    'setta elemento a val'
   }
  }
 };
 init(int len){
  'alloca spazio'
 };
 end(){
  'libera spazio'
 };
}
\end{verbatim}
\end{codeenv}
Per accedere al campo si devono specificare i parametri all'interno di parentesi quadre:
\begin{codeenv}
\begin{verbatim}
IntArray array = :new IntArray(5);
array.elem[3] = -34;
int v = array.elem[2 + 1]; // v == -34
\end{verbatim}
\end{codeenv}

\section{Modificatori di accesso: read e shadow}
Sempre per protezione, spesso si vuole impedire o limitare l'accesso ai campi da parte di moduli esterni. Per limitare l'accesso si utilizzano i seguenti modificatori di accesso:
\begin{itemize}
\item \emph{shadow} Impedisce completamente l'accesso al campo ai moduli esterni. Specificando un campo shadow implicitamente lo si rende explicit, quindi specificare un campo sia shadow che con un modificatore di memorizzazione diverso da explicit generer\ac a un errore del compilatore
\item \emph{read} Impedisce solo la scrittura al campo, non la lettura. Se il campo non \e explicit, verr\ac a generata solo la funzione di accesso in lettura, generando un errore nel caso si voglia creare anche una funzione di accesso in scrittura
\end{itemize}

Cos\ac i il nostro tipo IntArray diverr\ac a:
\begin{codeenv}
\begin{verbatim}
type IntArray{
 read int len;
 shadow pt pointer;//Punta alla memoria dell'array
 ghost int elem[int]{
  int get(int index){
   if((index >=0) && (index < len)){
    'ritorna elemento'
   }
   else
    return 0;
  }
  void set(int val, int index){
   if((index >=0) && (index < len)){
    'setta elemento a val'
   }
  }
 };
 init(int len){
  'alloca spazio'
 };
 end(){
  'libera spazio'
 };
}
\end{verbatim}
\end{codeenv}

\section{Campi packed}
Supponiamo di voler creare un tipo con 127 campi distinti di tipo real, abbiamo tre opzioni. La prima \e di scrivere manualmente tutti i 127 campi cambiando il nome di ciascuno di essi, la seconda \e di creare un array di 127 elementi, ma ci\ac o creerebbe un overhead non trascurabile e una gestione della memoria difficoltosa, in quanto in Meucci non \e presente il garbage collector come in Java. La terza opzione \e di utilizzare la parola chiave \emph{packed} seguita da 127, cos\ac i il compilatore generer\ac a automaticamente tutti i campi
\begin{codeenv}
\begin{verbatim}
type tti{
 real e packed 127;
}
\end{verbatim}
\end{codeenv}
L'accesso a ciascun campo viene effettuata come se avesse un parametro di tipo \emph{uint}
\begin{codeenv}
\begin{verbatim}
var.e[u59] = 34.89;
\end{verbatim}
\end{codeenv}

Se si dichiara un campo packed, non sar\ac a possibile assegnargli un modificatore di memorizzazione n\'e inserire funzioni di accesso, il campo dovr\ac a essere trattato come se fosse explicit.

Come vedremo nel prossimo capitolo, la lunghezza di un campo packed pu\ac o essere un template di tipo numerico, rendendo questo strumento molto utile in varie circostanze.

\section{Ereditariet\ac a}
Come nei linguaggi orientati ad oggetti, il linguaggio Meucci supporta il meccanismo dell'ereditariet\ac a (\emph{singola}). Per estendere un tipo basta inserire, dopo il nome del sovrattipo, la parola chiave \emph{extends} seguito dal nome del sottotipo:
\begin{codeenv}
\begin{verbatim}
type sovraT extends sottoT{
...
}
\end{verbatim}
\end{codeenv}
Il sovrattipo erediter\ac a tutti i dati del sottotipo, comprese le funzioni di accesso. Se il sovrattipo \e creato in un modulo diverso da quello in cui \e stato dichiarato il sottotipo, il modulo non potr\ac a accedere ai membri shadow ereditati e potr\ac a accedere solo in lettura ai campi read ereditati. In compenso, l'accesso ai dati ereditati sar\ac a diretto, a meno che il campo non sia ghost o vengano usati i due punti.

\subsection{Chiamata dei sovracostruttori}
Quando si deve inizializzare un sovrattipo \e necessario inizializzare anche i campi del sottotipo a cui non si avrebbe accesso (come i campi shadow). Per ovviare a ci\ac o la prima istruzione di un costruttore derivato deve essere una chiamata ad un costruttore del sottotipo, utilizzando la pseudo-istruzione \emph{super}:
\begin{codeenv}
\begin{verbatim}
...
init(){
 super(...);
 ...
}
...
\end{verbatim}
\end{codeenv}

\subsection{Il modificatore override}
La sovracclasse pu\ac o modificare le funzioni di accesso dei campi ereditati sostituendole con altre pi\ac u adatte. Per sovrascrivere le funzioni di accesso si riscrive nel sovrattipo il relativo campo con modificatore di memorizzazione \emph{override} e con l'eventuale modificatore di accesso e dei parametri di accesso, e quindi si scrivono le nuove funzioni di accesso che andranno a sostituire quelle vecchie.

Non \e possibile effettuare l'override di campi explicit o shadow, e per i campi read \e possibile modificare solo la funzione di lettura.

\chapter{Template}
Nel capitolo precedente abbiamo creato un tipo IntArray, un array di interi. Se ora volessimo creare un array di caratteri si dovrebbe creare un tipo CharArray, analogamente con ULongArray e cos\ac i via. Si nota che la maggior parte del codice \e lo stesso, cambia al massimo il tipo immagazzinato. Discorso analogo vale per le funzioni che operano su tali tipi.

Per questo \e comodo creare non un solo tipo o funzione, ma una \emph{famiglia di tipi e funzioni} con codice simile, in cui ciascun tipo o funzione \e univocamente determinato da uno o pi\ac u parametri. Una famiglia di tipi viene detta \emph{tipo template}, analogamente si dice \emph{funzione template}, mentre questi parametri di accesso sono detti \emph{parametri template}. Non si possono creare allo stato attuale operazioni template.

Quandi si compila, questi tipi e moduli non vengomo memorizzati all'interno di un file .in, ma il compilatore generer\ac a dei file .tin, generalmente pi\ac u pesanti, che devono essere utilizzati come i normali file di importazione.

\section{Parametri tipo e parametri numerici}
Per creare un tipo o una funzione template bisogna far seguire al nome del tipo/funzione, tra parentesi quadre, tutti i parametri template utilizzati. Esistono due tipi di parametri template:
\begin{itemize}
\item Parametri \emph{tipo}: il parametro pu\ac o essere il nome di un tipo qualunque. Bisogna far precedere al nome del parametro la parola \emph{typ}. Si possono aggiungere altre limitazioni ai valori ammissibili, poste dopo il nome del parametro: con \emph{number} il tipo pu\ac o essere solo un tipo intero (long, ushort, int, ...), mentre con \emph{reference} pu\ac o essere solo un tipo reference. Se si imposta la limitazione reference, si pu\ac o obbligare il parametro ad assumere solo nomi di tipi che estendono un determinato tiporeference tramite la parola \emph{extends} seguito dal sottotipo
\item Parametri \emph{numero}: il parametro pu\ac o essere una qualunque costante \emph{senza segno}. Bisogna far precedere al nome la parola chiave \emph{num} e far seguire un numero che ne esprime il tipo (0 \e ubyte, 1 \e ushort, 2 \e uint, 3 \e ulong). Si possono aggiungere limitazioni ai valori che il parametro pu\ac o assumere tramite i simboli > e < seguiti da costanti, che esprimono l'estremo inferiore e superiore del parametro.
\end{itemize}
Esempio:
\begin{codeenv}
\begin{verbatim}
type temp[typ T reference extends Frazione, num N 3 > 2 < 4]{
 init(){
 ...
 }
...
}
\end{verbatim}
\end{codeenv}
definisce per il tipo temp due parametri template: T parametro tipo reference che estende il tipo Frazione, N parametro numerico di tipo ulong maggiore di 2 e minore di 4 (pu\ac o essere solo 3).

L'esempio seguente mostra come dichiarare e allonare memoria ad una variabile del tipo ottenuto dal tipo template temp con T = Intero (che estende il tipo Frazione semplicemente ponendo den=1) e N = 3:
\begin{codeenv}
\begin{verbatim}
temp[Intero, 3] var = :new temp[Intero, 3]();
//Le costanti utilizzate come parametri numerici sono 
//sempre unsigned, anche se manca il prefisso u
\end{verbatim}
\end{codeenv}

\section{Funzioni template}
Ci sono inoltre delle \emph{funzioni template}, ovvero funzioni definite dal compilatore che prendono come input parametri template e ritornano un parametro template:
\begin{itemize}
\item \emph{SIZEOF} Accetta come parametro un parametro tipo e ritorna come parametro numerico la dimensione in byte della quantit\ac a di memoria allocata durante la dichiarazione
\item \emph{DIMENSION} Accetta un parametro tipo reference e ritorna come parametro numerico la dimensione in byte dell'oggetto
\item \emph{SUM} Accetta due o pi\ac u costanti o parametri numerici e ritorna un parametro numerico che \e la somma degli input
\item \emph{PROD} Accetta due o pi\ac u costanti o parametri numerici e ritorna un parametro numerico che \e il prodotto degli input
\end{itemize}
Quando viene utilizzato una funzione template, deve essere preceduta dal simbolo cancelletto \verb&#& e i parametri devono essere racchiusi tra parentesi tonde e separati da virgole
\begin{codeenv}
\begin{verbatim}
uint vay = #SUM(u2, 3);
\end{verbatim}
\end{codeenv}

\appendix
\chapter{Array e StaticArray}
Due tipi template molto utili e utilizzati sono \emph{Array} (un array in Java) e \emph{StaticArray} (un array in C), definiti entrambi nel modulo \emph{Arrays} incluso di default in tutti i progetti. Il loro codice \e molto utile per comprendere il funzionamento dei parametri template, per questo verr\ac a riportato integralmente in questa appendice:
\begin{codeenv}
\begin{verbatim}
modulo Arrays depends Memory{
 type Array[typ T]{
  explicit read uint length;
  shadow pointer[T] memory;
  ghost T elem[uint]{
   T get(uint index){
    if(index < this.length){
     pointer[T] val=somma[T](this.memory, index);
     return val.el;
    }
    else{
     return (T) null; //Condizione di errore
    }
   }
   void set(T va, uint index){
    if(index < this.length){
     pointer[T] val=somma[T](this.memory, index);
     val.el=va;
    }
   }
  };
  init(uint size){
   pt memory=allocate(#SIZEOF(T)*size);
   this.memory=(pointer[T])memory;
   this.length=size;
  };
  end(){
   free((pt)this.memory);
  };
 }
 type explicit StaticArray[typ T, num L 2]{
  T elem packed L;
  init(){
   //Non e' necessario il costruttore,
   //in quanto l'allocazione della memoria
   //e' statica
  };
 }
}
\end{verbatim}
\end{codeenv}
\begin{codeenv}
\begin{verbatim}
Array[ubyte] b = :stack Array[ubyte](u2 + u1);
StaticArray[ubyte, 3] sb = :stack[ubyte, 3]();
b.elem[1] = u12b;
sb.elem[0] = b.elem[1] +u1B; 
\end{verbatim}
\end{codeenv}
La differenza sta nel fatto che la dimensione del tipo Array si pu\ac o determinare solo in fase di esecuzione, e quindi \e necessario allocare dinamicamente la memoria, mentre la dimensione di StaticArray \e determinata gi\ac a in fase di compilazione (tramite il parametro template numerico L) e quindi il compilatore conosce gi\ac a la dimensione dell'array.

\begin{codeenv}
\begin{verbatim}
type explicit pointer[typ TT]{
 TT el;
}
\end{verbatim}
\end{codeenv}
Il tipo template pointer[T] va inteso come un puntatore a elementi (non per forza oggetti) di tipo T.

\chapter{Funzionalit\ac a future}
Ecco un breve elenco delle funzionalit\ac a che forse verranno aggiunte nelle prossime versioni del compilatore
\begin{itemize}
\item Gestione eccezioni
\item Possibilit\ac a di definire nuovi tipi primitivi
\item Libreria multithreading
\item Protocolli, ovvero astrazioni che permette il caricamento dinamico di moduli
\item Possibilit\ac a all'interno di funzioni di accesso di chiamare le precedenti funzioni di accesso, al fine di migliorare la protezione dei dati membro
\end{itemize}
\end{document}
